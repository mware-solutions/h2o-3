# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_R.py
# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details) 
#'
# -------------------------- rulefit -------------------------- #
#'
#' @param x (Optional) A vector containing the names or indices of the predictor variables to use in building the model.
#'        If x is missing, then all columns except y are used.
#' @param y The name or column index of the response variable in the data. 
#'        The response must be either a numeric or a categorical/factor variable. 
#'        If the response is numeric, then a regression model will be trained, otherwise it will train a classification model.
#' @param training_frame Id of the training data frame.
#' @param model_id Destination id for this model; auto-generated if not specified.
#' @param seed Seed for random numbers (affects certain parts of the algo that are stochastic and those might or might not be enabled by default).
#'        Defaults to -1 (time-based random number).
#' @param algorithm The algorithm to use to generate rules. Must be one of: "AUTO", "DRF", "GBM". Defaults to AUTO.
#' @param min_rule_length Minimum length of rules. Defaults to 1. Defaults to 1.
#' @param max_rule_length Maximum length of rules. Defaults to 10. Defaults to 10.
#' @param max_num_rules The maximum number of rules to return. defaults to -1 which means the number of rules is selected  by
#'        diminishing returns in model deviance. Defaults to -1.
#' @param model_type Specifies type of base learners in the ensemble. Must be one of: "RULES_AND_LINEAR", "RULES", "LINEAR".
#'        Defaults to RULES_AND_LINEAR.
#' @examples
#' \dontrun{
#' library(h2o)
#' h2o.init()
#' 
#' # Run regression GBM on australia data
#' australia_path <- system.file("extdata", "australia.csv", package = "h2o")
#' australia <- h2o.uploadFile(path = australia_path)
#' independent <- c("premax", "salmax", "minairtemp", "maxairtemp", "maxsst",
#'                  "maxsoilmoist", "Max_czcs")
#' dependent <- "runoffnew"
#' h2o.gbm(y = dependent, x = independent, training_frame = australia,
#'         ntrees = 3, max_depth = 3, min_rows = 2)
#' }
#' @export
h2o.rulefit <- function(x,
                        y,
                        training_frame,
                        model_id = NULL,
                        seed = -1,
                        algorithm = c("AUTO", "DRF", "GBM"),
                        min_rule_length = 1,
                        max_rule_length = 10,
                        max_num_rules = -1,
                        model_type = c("RULES_AND_LINEAR", "RULES", "LINEAR"))
{
  # Validate required training_frame first and other frame args: should be a valid key or an H2OFrame object
  training_frame <- .validate.H2OFrame(training_frame, required=TRUE)

  # Validate other required args
  # If x is missing, then assume user wants to use all columns as features.
  if (missing(x)) {
     if (is.numeric(y)) {
         x <- setdiff(col(training_frame), y)
     } else {
         x <- setdiff(colnames(training_frame), y)
     }
  }

  # Build parameter list to send to model builder
  parms <- list()
  parms$training_frame <- training_frame
  args <- .verify_dataxy(training_frame, x, y)
  parms$ignored_columns <- args$x_ignore
  parms$response_column <- args$y

  if (!missing(model_id))
    parms$model_id <- model_id
  if (!missing(seed))
    parms$seed <- seed
  if (!missing(algorithm))
    parms$algorithm <- algorithm
  if (!missing(min_rule_length))
    parms$min_rule_length <- min_rule_length
  if (!missing(max_rule_length))
    parms$max_rule_length <- max_rule_length
  if (!missing(max_num_rules))
    parms$max_num_rules <- max_num_rules
  if (!missing(model_type))
    parms$model_type <- model_type

  # Error check and build model
  model <- .h2o.modelJob('rulefit', parms, h2oRestApiVersion=3, verbose=FALSE)
  return(model)
}
.h2o.train_segments_rulefit <- function(x,
                                        y,
                                        training_frame,
                                        seed = -1,
                                        algorithm = c("AUTO", "DRF", "GBM"),
                                        min_rule_length = 1,
                                        max_rule_length = 10,
                                        max_num_rules = -1,
                                        model_type = c("RULES_AND_LINEAR", "RULES", "LINEAR"),
                                        segment_columns = NULL,
                                        segment_models_id = NULL,
                                        parallelism = 1)
{
  # formally define variables that were excluded from function parameters
  model_id <- NULL
  verbose <- NULL
  destination_key <- NULL
  # Validate required training_frame first and other frame args: should be a valid key or an H2OFrame object
  training_frame <- .validate.H2OFrame(training_frame, required=TRUE)

  # Validate other required args
  # If x is missing, then assume user wants to use all columns as features.
  if (missing(x)) {
     if (is.numeric(y)) {
         x <- setdiff(col(training_frame), y)
     } else {
         x <- setdiff(colnames(training_frame), y)
     }
  }

  # Build parameter list to send to model builder
  parms <- list()
  parms$training_frame <- training_frame
  args <- .verify_dataxy(training_frame, x, y)
  parms$ignored_columns <- args$x_ignore
  parms$response_column <- args$y

  if (!missing(seed))
    parms$seed <- seed
  if (!missing(algorithm))
    parms$algorithm <- algorithm
  if (!missing(min_rule_length))
    parms$min_rule_length <- min_rule_length
  if (!missing(max_rule_length))
    parms$max_rule_length <- max_rule_length
  if (!missing(max_num_rules))
    parms$max_num_rules <- max_num_rules
  if (!missing(model_type))
    parms$model_type <- model_type

  # Build segment-models specific parameters
  segment_parms <- list()
  if (!missing(segment_columns))
    segment_parms$segment_columns <- segment_columns
  if (!missing(segment_models_id))
    segment_parms$segment_models_id <- segment_models_id
  segment_parms$parallelism <- parallelism

  # Error check and build segment models
  segment_models <- .h2o.segmentModelsJob('rulefit', segment_parms, parms, h2oRestApiVersion=3)
  return(segment_models)
}
